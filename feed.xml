<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The Gold Bug</title>
  <id>http://rmoliva.github.io</id>
  <link href="http://rmoliva.github.io"/>
  <link href="http://rmoliva.github.io/feed.xml" rel="self"/>
  <updated>2016-08-20T02:00:00+02:00</updated>
  <author>
    <name>Roberto M. Oliva</name>
  </author>
  <entry>
    <title>The FRP landscape</title>
    <link rel="alternate" href="http://rmoliva.github.io/posts/2016-08-20-the_frp_landscape/"/>
    <id>http://rmoliva.github.io/posts/2016-08-20-the_frp_landscape/</id>
    <published>2016-08-20T02:00:00+02:00</published>
    <updated>2016-08-20T12:17:47+02:00</updated>
    <author>
      <name>Roberto M. Oliva</name>
    </author>
    <content type="html">&lt;p&gt;
  Each passing day I am more convinced that Functional programming is the way to go:
  &lt;ul&gt;
    &lt;li&gt;Pure functions&lt;/li&gt;
    &lt;li&gt;Declarative programming&lt;/li&gt;
    &lt;li&gt;Monad types&lt;/li&gt;
    &lt;li&gt;etc&lt;/li&gt;
  &lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;
  As an analist and developer I continuosly try to reach the same horizon: Better valuable code for my client. This pretty sentence can be translated to the following:
  &lt;ul&gt;
    &lt;li&gt;Easier to include advanced functionality and UI&lt;/li&gt;
    &lt;li&gt;More tested code&lt;/li&gt;
    &lt;li&gt;Easier to read amd mantain&lt;/li&gt;
    &lt;li&gt;Easier to refactor and improve&lt;/li&gt;
    &lt;li&gt;etc&lt;/li&gt;
  &lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;
  Functional programming has proved to help get those targets in better conditions.
&lt;/p&gt;
&lt;p&gt;
  There are a new breed of tools, named Functional Reactive Programming (FRP), that tries to deal the asynchronous JavaScript nature with a Functional approach. I am going to use this post as a directory for those tools.
&lt;/p&gt;

&lt;h2&gt;Functional Libraries&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;a href='http://ramdajs.com/'&gt;Ramda&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href='https://github.com/lodash/lodash/wiki/FP-Guide'&gt;Lodash FP&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href='http://danieltao.com/lazy.js/'&gt;Lazy JS&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href='http://functionaljs.com/'&gt;Function JS&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Monads&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;a href='https://github.com/ramda/ramda-fantasy'&gt;Ramda Fantasy&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href='https://github.com/ramda/ramda-fantasy'&gt;Monet JS&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href='https://github.com/folktale'&gt;Folktale&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FRP Libraries&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;a href='https://github.com/Reactive-Extensions/RxJS'&gt;RxJS&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href='https://baconjs.github.io/'&gt;BaconJS&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href='https://github.com/cujojs/most'&gt;MostJS&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href='http://highlandjs.org/'&gt;Highland&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href='https://rpominov.github.io/kefir/'&gt;Kefir&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href='https://github.com/staltz/xstream'&gt;XStream&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href='https://github.com/paldepind/flyd'&gt;Flyd&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;FRP framworks&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;a href='http://cycle.js.org/'&gt;Cycle JS&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href='https://github.com/tsers-js/core/'&gt;TSERS JS&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a href='https://github.com/calmm-js'&gt;Calm^2 JS&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  As you can see in the following link:
  &lt;a href='https://github.com/xgrommx/awesome-functional-programming'&gt;Awesome Functional programming&lt;/a&gt;
  There are many, many more.
  &lt;br&gt;
  I will put in this blog my experiences with some of this libraries.
&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>JavaScript: Promise Patterns for scaleApp Applications</title>
    <link rel="alternate" href="http://rmoliva.github.io/posts/2015-02-14-javascript_promise_patterns_scaleapp/"/>
    <id>http://rmoliva.github.io/posts/2015-02-14-javascript_promise_patterns_scaleapp/</id>
    <published>2015-02-14T01:00:00+01:00</published>
    <updated>2016-08-17T10:13:09+02:00</updated>
    <author>
      <name>Roberto M. Oliva</name>
    </author>
    <content type="html">&lt;p&gt;
  I love
  &lt;a href="http://scaleapp.org/"&gt;scaleApp&lt;/a&gt;
  .
  It helps us modularize and divide an application in well-formed, isolated modules. It also provides a communication means between them all and sets a convenience infraestructure to put the pieces together. It is also easy to learn and to follow.
&lt;/p&gt;
&lt;p&gt;
  In all this time using it I ended writting a set of promise functions that help isolate some common issues of  scaleApp in a recurring manner.
&lt;/p&gt;

&lt;h2&gt;Module lifecycle&lt;/h2&gt;
&lt;p&gt;
  The following is the code for an empty module that responds to the
  &lt;i&gt;initialize&lt;/i&gt;
  and
  &lt;i&gt;destroy&lt;/i&gt;
  methods always as if it is an asynchronous module (see the
  &lt;i&gt;done&lt;/i&gt;
  function):
&lt;/p&gt;
&lt;pre&gt;&lt;code class='javascript'&gt;var MyModule = function(sandbox){&amp;#x000A;	return {&amp;#x000A;		init: function(options, done){&amp;#x000A;			done();&amp;#x000A;		},&amp;#x000A;		destroy: function(done){&amp;#x000A;			done();&amp;#x000A;	  }&amp;#x000A;  };&amp;#x000A;};&amp;#x000A;core.register('myModule', MyModule);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  So, the two firsts promise functions are in charge of start and stop a module:
&lt;/p&gt;
&lt;pre&gt;&lt;code class='javascript'&gt;var moduleStart = function(module, options) {&amp;#x000A;	return new Promise(function(resolve, error) {&amp;#x000A;		core.start(module, {&amp;#x000A;			options: options&amp;#x000A;		}, resolve );&amp;#x000A;	});&amp;#x000A;};&amp;#x000A;&amp;#x000A;var moduleStop = function(module, options) {&amp;#x000A;  return new Promise(function(resolve, error) {&amp;#x000A;	  core.stop(module, resolve);&amp;#x000A;  });&amp;#x000A;};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  Well, nothing outrageous. But it help us to start modules as promises with all of it’s advantages. For example: it is very easy to read and tweek the following code:
  &lt;pre&gt;&lt;code class='javascript'&gt;moduleStart('loader', options).then(function() {&amp;#x000A;  return moduleStop('loader', options);&amp;#x000A;}).then(function() {&amp;#x000A;  return Promise.all([&amp;#x000A;	  moduleStart('header')&amp;#x000A;	  moduleStart('main_layout')&amp;#x000A;	  moduleStart('footer')&amp;#x000A;  ]);&amp;#x000A;}).done(function() {&amp;#x000A;  return moduleStart('dashboard');&amp;#x000A;});&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;
&lt;h2&gt;Module communication&lt;/h2&gt;
&lt;p&gt;
  Another common pattern is the communication between modules. When a module wants another to do something it sends a signal event to the performer module. Here again I force the system to work in an asynchronous manner so the receiver module should always signal a finished event even if all the work is done inside, for example, one method.
&lt;/p&gt;
&lt;p&gt;
  The promise that performs this functionality is the following:
&lt;/p&gt;
&lt;pre&gt;&lt;code class='javascript'&gt;var emitEvent = function(startEvent, endEvent, data) {&amp;#x000A; return new Promise(function(resolve, reject) {&amp;#x000A;	 var subscription;&amp;#x000A;	 subscription = core.on(endEvent, function() {&amp;#x000A;		 subscription.detach();&amp;#x000A;		 resolve();&amp;#x000A;	 });&amp;#x000A; 	 core.emit(startEvent);&amp;#x000A; });&amp;#x000A;};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  I usually wrap all the events inside promise functions keeping the definition of the event names from spreading accross different parts of the application. 
&lt;/p&gt;
&lt;p&gt;
  For example the following are several helper functions that allows to send events from one module to another:
&lt;/p&gt;
&lt;pre&gt;&lt;code class='javascript'&gt;var headerShowSpinner = function(data) {&amp;#x000A;  return emitEvent('header.showSpinner', 'header.showSpinnerEnd', data);&amp;#x000A;};&amp;#x000A;&amp;#x000A;var headerHideSpinner = function(data) {&amp;#x000A;  return emitEvent('header.hideSpinner', 'header.hideSpinnerEnd', data);&amp;#x000A;};&amp;#x000A;&amp;#x000A;var mainLoadPanel = function(data) {&amp;#x000A;  return emitEvent('main.loadPanel', 'main.loadPanelEnd', data);&amp;#x000A;};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  Once again this helps us writing code that is easier to tweek and understand. See how the module that invokes the following doesn’t need to know the name of the events but only the functionality:
&lt;/p&gt;
&lt;pre&gt;&lt;code class='javascript'&gt;headerShowSpinner().then(function() {&amp;#x000A;  return mainLoadPanel(options);&amp;#x000A;}).done(function() {&amp;#x000A;  headerHideSpinner();&amp;#x000A;});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  These are just simple patterns. It is not rocket science. It just helped me and I hope it helps you.
&lt;/p&gt;
</content>
  </entry>
</feed>
